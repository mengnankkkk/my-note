---
title: 计算机网络基础
categories:
  - 408
abbrlink: 2708
date: 2025.2.23
tags:
  - net
---

# 基本概念

## 传输方式

网络根据传输方式可以进行分类，一般分为**面向连接型和面向无连接型**。

- 面向连接型中，在发送数据之前，需要在主机之间建立一条通信线路。
- 面向无连接型则不要求建立和断开连接，发送方可用于任何时候发送数据。接收端也不知道自己何时从哪里接收到数据。

## 分组交换

处在互联网边缘部分的机器，也就是互联网终端主机，它们官方一点的话术就是端系统。

在互联网应用中，每个终端系统都可以彼此交换信息，这种信息也被称为`报文(Message)`，报文是一个超集的概念，它可以包括你想要的任何东西，比如文字、数据、电子邮件、音频、视频等。为了从源目的地向端系统发送报文，需要把长报文切分为一个个小的数据块，这种数据块称为`分组(Packets)`，也就是说，报文是由一个个小块的分组组成。

这些分组其实就是**包**

在分组的传输过程中，每个分组都要经过通信链路和分组交换机，分组要在端系统之间传输需要经过一定的时间，如果两个端系统之间需要传输的分组为 L 比特，链路的传输速率问 R 比特/秒，那么传输时间就是 L / R秒。

一个端系统需要经过交换机给其他端系统发送分组，当分组到达分组交换机时，交换机会如何操作？交换机会直接进行转发吗？不是的，交换机可没有这么无私，你想让我帮你转发分组？好，首先你需要先把整个分组数据都给我，我再考虑给你发送的问题，这就是**存储转发传输**。

# 数据在不同层的称呼

四层传输层数据被称作**段**（Segments）；

三层网络层数据被称做**包**（Packages）；

二层数据链路层时数据被称为**帧**（Frames）；

一层物理层时数据被称为**比特流**（Bits）。

# 网络层

## IP地址

**网络ip地址：**

IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。

**广播地址：**

广播地址通常称为直接广播地址，是为了区分受限广播地址。

广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。

**组播地址：**

D类地址就是组播地址。

**A，B，C，D类地址**

A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；

B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;

C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。

D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；

E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。

注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。

**255.255.255.255**

**该IP地址指的是受限的广播地址**。受限广播地址与一般广播地址（直接广播地址）的区别在于，**受限广播地址只能用于本地网络**，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。

注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。

**0.0.0.0**

**常用于寻找自己的IP地址**，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。

回环地址：

127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是**127.0.0.1。** 也可以用**localhost**来表示

**A、B、C类私有地址**

私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。

A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255

B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255

C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255

## 子网掩码

随着互连网应用的不断扩大，原先的IPv4的弊端也逐渐暴露出来，即网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供给不同规模的用户群使用。

这里主要是为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。但创建更多的子网时，在每个子网上的可用主机地址数目会比原先减少。

子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果**两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中**。

**在计算子网掩码时，我们要注意IP地址中的保留地址，即" 0"地址和广播地址，它们是指主机地址或网络地址全为" 0"或" 1"时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。**

### 子网掩码的计算

无需划分：

在这个无须划分子网里面是按ip地址的类别决定的。比如A类地址占8个网络位，所以是255.0.0.0

B类地址占16个网络位，所以子网掩码就是255.255.0.0

C类地址占24个网络位，所以子网掩码就是255.255.255.0

固定大小的子网：

通常用于根据特定的网络需求（如特定数量的主机或子网）来划分。计算的关键是确定所需的网络位数和主机位数，并根据此来计算掩码。

- 确定需要多少个子网，或者每个子网需要多少主机。

- 使用**2的幂**来推算所需的主机位数或子网位数。

- 将其与默认子网掩码结合，进行扩展。

实例：

假设你有一个**A类地址**`10.0.0.0`，默认子网掩码是`255.0.0.0`。你希望把这个地址划分为**4个子网**。

需要划分为4个子网，那么就需要2个子网位，然后又是A类地址，8个网络位。所以一共是10个网络位

所以新的子网掩码就是（前10位是1，其余是0）

11111111.11000000.00000000.00000000

转化为10进制就是

**255.192.0.0**

根据主机数来确定：

这种方法是通过需求来计算每个子网所能容纳的最大主机数，从而确定子网掩码。

- 根据你想要的每个子网中的主机数，反推所需的主机位数。

- 用**2的幂**来计算能容纳的最大主机数。公式：`2^n - 2`（减去2是因为网络地址和广播地址不能用作主机地址）。

- 然后确定剩下的位数就是网络位数，从而确定子网掩码。

实例：

假设你想要为每个子网容纳50个主机

2^n - 2 >= 50

`2^6 - 2 = 62`，所以需要6个主机位。

如果是C类地址，默认掩码是`255.255.255.0`，即24个网络位。

所以那么子网掩码用二进制表示就是

现在，给定6个主机位，网络位数是：`32 - 6 = 26`

11111111.11111111.11111111.11000000

转化为10进制就是**255.255.255.192**

CIDR表示法：

它允许你直接指定子网掩码的位数，而不是依赖于IP地址的类别。CIDR表示法用斜杠后跟数字的形式表示子网掩码。

- CIDR表示法是通过直接指明网络部分的位数来计算子网掩码。例如，`/24` 表示前24位是网络位，后8位是主机位。

- 你可以通过CIDR来指定任何IP地址和子网掩码，而不仅仅是A类、B类或C类地址。

`10.0.0.0/8`：表示A类地址 `10.0.0.0`，子网掩码为 `255.0.0.0`。

`172.16.0.0/16`：表示B类地址 `172.16.0.0`，子网掩码为 `255.255.0.0`。

`192.168.1.0/24`：表示C类地址 `192.168.1.0`，子网掩码为 `255.255.255.0`。

主机和子网的地址进行计算：

比如一个子网有10台主机，那么对于这个子网需要的IP地址是：

```
10＋1＋1＋1＝13
```

**注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址**

网关也是要占地址的

13小于16（2的四次方）所以主机位是4位。256-16=240

所以子网掩码是**255.255.255.240**

## 网关

网关实质上是一个网络通向其他网络的IP地址。

比如有网络A和网络B，网络A的IP地址范围为`192.168.1.1~192. 168.1.254`，子网掩码为`255.255.255.0`；

网络B的IP地址范围为`192.168.2.1~192.168.2.254`，子网掩码为`255.255.255.0`。

而要实现这两个网络之间的通信，则必须通过网关。

**所以说，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。**

如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程。

网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器(实质上相当于一台路由器)、代理服务器(也相当于一台路由器)。



# 网络协议

核心作用：

- **标准化通信：**网络协议为设备之间的通信提供了统一的标准，确保不同厂商、不同操作系统的设备能够互联互通。
- **数据可靠传输：**通过错误检测、数据重传等机制，网络协议确保数据在传输过程中不会丢失或损坏。
- **高效路由与寻址：**网络协议定义了如何将数据从源设备发送到目标设备，包括地址分配、路由选择等。
- **安全性：**现代网络协议通常包含加密和认证机制，保护数据免受窃听或篡改。

关键组成部分：

- **语法:** 定义数据的格式和结构。例如，数据包的头部和尾部如何组织。
- **语义:** 定义数据的含义。例如，某个字段表示源地址，另一个字段表示目标地址。
- **时序:** 定义数据发送和接收的顺序。例如，TCP协议的三次握手过程。
- **网络协议的分层结构:** 网络协议通常按照分层模型组织，最常见的模型是 OSI七层模型 和 TCP/IP四层模型。每一层都有特定的功能和协议。

## 网络通信

网络通信是指通过计算机网络（如互联网）**在不同设备之间传输数据的过程。**这些设备可以是计算机、智能手机、服务器等。网络通信的核心目标是**实现信息的快速、准确和安全传输。**

基本要素：

- **发送方（Sender）**：发送数据的设备或应用程序。
- **接收方（Receiver）**：接收数据的设备或应用程序。
- **传输介质（Transmission Medium）**：数据在网络中传输的物理路径，如光纤、电缆、无线信号等。
- **协议（Protocol）**：规定数据如何传输、如何被接收和处理的规则和标准。

在网络通信中，数据通常以"包"（Packet）的形式传输。数据封装是指将原始数据按照特定的协议格式打包，添加必要的控制信息（如源地址、目标地址、校验和等）。解封装则是接收方将接收到的数据包还原为原始数据的过程。

传输过程：

1. **数据分段**：将大块数据分割成适合传输的小块。
2. **添加头部信息**：在每个数据段前添加协议头部信息，如IP地址、端口号等。
3. **传输**：通过网络传输介质将数据包发送到目标设备。
4. **接收与重组**：接收方接收数据包，并根据头部信息将数据包重组为原始数据。

在网络通信中，数据被分割成小块进行传输，这些小块被称为数据包、帧或报文，具体名称取决于所在的网络层次。

- **数据包（Packet）:** 在网络层（如IP协议）中，数据被封装成数据包，包含源地址、目标地址和数据内容。
- **帧（Frame）:** 在数据链路层（如以太网协议）中，数据包被进一步封装成帧，包含MAC地址和错误检测信息。
- **报文（Message）:** 在应用层（如HTTP协议）中，数据以报文的形式传输，包含请求或响应的具体内容。

网络通信的基本流程：

1. **数据封装**
   - 应用层生成数据报文。
   - 传输层添加端口号（TCP/UDP）。
   - 网络层添加IP地址（IP）。
   - 数据链路层添加MAC地址（帧）。
   - 物理层将数据转换为比特流。
2. **数据传输**
   - 数据通过物理介质（如电缆、光纤）传输。
3. **数据解封装**
   - 接收设备逐层解析数据，最终将数据传递给目标应用程序。



## ARP/RARP协议

**地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议**

ARP 把 IP 地址解析为硬件地址

主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。

**ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。**

**逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址**

ARP工作流程：

- **主机A查询ARP缓存**：主机A检查是否有主机B的IP地址和MAC地址映射。如果有，直接使用该映射进行通信。

- **ARP请求广播**：如果ARP缓存中没有对应的映射，主机A会向网络广播ARP请求，询问目标IP（192.168.1.2）的MAC地址，ARP请求包括主机A的IP和MAC地址。

- **主机B接收ARP请求**：网络中的所有主机接收到ARP请求，检查IP地址是否匹配。如果匹配，则继续处理请求；否则丢弃请求。

- **主机B发送ARP回复**：主机B回复ARP请求，发送自己的MAC地址给主机A。

- **主机A更新ARP缓存**：主机A接收到主机B的ARP回复后，更新ARP缓存，并使用主机B的MAC地址进行通信。

- **缓存生存期**：ARP缓存的条目有生存期，生存期过后，主机A需要重新进行ARP过程以更新MAC地址映射。

RARP工作流程：

- 给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；
- 本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；
- 如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；
- 如果不存在，RARP服务器对此不做任何的响应；

## 路由选择协议

常见的路由选择协议有：RIP协议、OSPF协议。

RIP协议 ：底层是**贝尔曼福特算法**，它选择路由的度量标准（metric)是跳数，最大跳数是**15跳**，如果大于15跳，它就会丢弃数据包。

OSPF协议 ：Open Shortest Path First开放式最短路径优先，底层是**迪杰斯特拉算法**，是链路状态路由选择协议，它选择路由的度量标准是**带宽，延迟**。

## tcp/ip

TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：**TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。**

IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层---TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。

TCP是面向连接的通信协议，是一个**传输层协议**，是一个**双工协议**，这就意味着客户端和服务端可以平等地发送、接收信息。通过**三次握手**建立连接，通讯完成时要通过**四次挥手**拆除连接，这个连接就是一个通道，由于TCP是面向连接的所以只能用于**端到端**（套接字到套接字）的通讯。TCP提供的是一种可靠的**数据流**服务，采用"带重传的肯定确认"技术来实现传输的可靠性。TCP还采用一种称为"滑动窗口"的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。**面向字节流**。虽然应用程序与TCP交互是一次一个大小不等的数据块，但**TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系**，例如，发送方应用程序交给发送方的TCP10个数据块，接收方的TCP可能只用收到的4个数据块字节流交付给上层的应用程序

### tcp的可靠性原理

可靠传输有如下两个特点:

1. 传输信道无差错,保证传输数据正确;
2. 不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据;

首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，**从而保证建立的传输信道是可靠的**。

其次，TCP采用了连续ARQ协议（回退N(Go-back-N)；超时自动重传）来保证数据传输的正确性，使用**滑动窗口协议**来保证接方能够及时处理所接收到的数据，进行流量控制。

最后，TCP使用**慢开始、拥塞避免、快重传和快恢复**来进行拥塞控制，避免网络拥塞。

### **TCP报文段**

TCP虽面向字节流，但传送的数据单元为报文段

报文段=首部+数据两部分

1. 首部前20个字符固定、后面有4n个字节是根据需而增加的选项
2. 故 TCP首部最小长度 = 20字节

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-8011660d-24c8-460f-ac3d-b97ad9c99b13.png)

![](https://www.runoob.com/wp-content/uploads/2018/09/1538030297-3779-20150904110054856-961661137.png)

**端口**：

源端口号和目地端口各占16位两个字节，也就是端口的范围是`2^16=65535`

另外1024以下是系统保留的，从1024-65535是用户使用的端口范围（一般常用的某些端口，比如5244,8080）

**seq序号**：

占4字节，TCP连接中传送的字节流中的每个字节都按顺序编号。

**ack确认号**：4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。

B收到A发送的报文，其序号字段是301，数据长度是200字节，表明B正确收到A发送的到序号500为止的数据（301+200-1=500），B期望收到A下一个数据序号是501，B发送给A的确认报文段中把ack确认号置为501。

**数据偏移**：

头部有可选字段，长度不固定，指出TCP报文段的数据起始处距离报文段的起始处有多远。

**保留**：保留今后使用的，标记为1

**控制位**：由8个标志位构成，每个标志位表示一个控制功能。

其中比较重要的6个：

- **URG紧急指针标志**，为1表示紧急指针有效，为0忽略紧急指针。
- **ACK确认序号标志**，为1表示确认号有效，为0表示报文不含确认信息，忽略确认号字段，上面的确认号是否有效就是通过该标识控制的。
- **PSH标志**，为1表示带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将该报文段交给应用程序，而不是在缓冲区排队。
- **RST重置连接标志**，重置因为主机崩溃或其他原因而出现错误的连接，或用于拒绝非法的报文段或非法的连接。
- **SYN同步序号**，同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。。
- **FIN终止标志**，用于释放连接，为1时表示发送方没有发送了。

**窗口**：滑动窗口的大小，用来告知发送端接受端缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。

**校验和**：奇偶校验，此校验和是对整个的TCP报文段（包括TCP头部和TCP数据），以16位进行计算所得，由发送端计算和存储，接收端进行验证。

**紧急指针**：只有控制位中的URG为1时才有效，指出本报文段中的紧急数据的字节数

**选项**：其长度可变，定义其他的可选参数

### **tcp的三次握手和三次挥手**

**三次握手**：用来建立 TCP 连接，确保双方都准备好进行数据传输：

1. 客户端发送 SYN 请求，表示希望建立连接。
2. 服务器回复 SYN-ACK，表示同意建立连接。
3. 客户端发送 ACK 确认，连接建立成功。

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-f6a9438e-4eb8-4573-9ef5-30e07b8c31df.png)

详细的过程

第一次握手：客户端将TCP报文标志位`SYN`置为1，随机产生一个序号值`seq=J`，保存在TCP首部的序列号字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入`SYN_SENT`状态，等待服务器端确认。

第二次握手：服务器端收到数据包后由标志位`SYN=1`知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，`ack=J+1`，随机产生一个序号值`seq=K`，并将该数据包发送给客户端以确认连接请求，服务器端进入`SYN_RCVD`状态。

服务器第一次收到客户端的 SYN 之后，就会处于 `SYN_RCVD`状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为**半连接队列**。

服务器发送完**SYN－ACK**包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的**最大重传次数**，系统将该连接信息从**半连接队列**中删除。

第三次握手：客户端收到确认后，检查ack是否为`J+1`，ACK是否为1，如果正确则将标志位ACK置为1，`ack=K+1`，并将该数据包发送给服务器端，服务器端检查ack是否为`K+1`，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入`ESTABLISHED`状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。

**全连接队列**就是三次握手已经完成了，建立起的连接就会放到全连接队列里，队列满了就会出现丢包。

其实第三次握手的时候，是可以携带数据的，也就是说，第一次、第二次握手不可以携带数据，而**第三次握手是可以携带数据**的。

其中上面的ack和ACK不是同一个概念

- 小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，`ack=seq+1`。
- 大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。



**四次挥手**：用来关闭连接，确保双方都完成数据的传输后才断开连接：

1. 客户端发送 FIN 请求，表示数据发送完毕，准备关闭连接。
2. 服务器回复 ACK，确认收到客户端的关闭请求。
3. 服务器发送 FIN 请求，表示服务器也准备关闭连接。
4. 客户端回复 ACK，连接正式关闭。

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-4a5e455f-5cf8-47a6-8fe4-a4c83a445f77.png)

挥手请求可以是Client端，也可以是Server端发起的，我们假设是Client端发起：

第一次挥手：Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入`FIN_WAIT_1`状态，这表示Client端没有数据要发送给Server端了。

第二次挥手：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入`FIN_WAIT_2`状态，Server端告诉Client端，我确认并同意你的关闭请求。

第三次挥手：Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入`LAST_ACK`状态。

第四次挥手：Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入`TIME_WAIT`状态，Server端收到Client端的ACK报文段以后，就关闭连接，此时，Client端等待**2MSL**的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。

**MSL**：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。

为什么要三次握手？

在只有两次"握手"的情形下，假设Client想跟Server建立连接，但是**却因为中途连接请求的数据报丢失了**，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被**阻塞**了，这种情形下**Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据**...问题就在这里，**Cient端实际上只有一次请求，而Server端却有2个响应，**极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，**因而造成极大的资源浪费**！所以，"三次握手"很有必要！

为什么要四次挥手？

试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是**保证双方的一个合约的完整执行**！

使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。

### Socket 

即套接字，是应用层 与 `TCP/IP` 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-eff20ef6-9d35-4075-8c53-ab52c7a46ac7.png)

`Socket`不是一种协议，而是一个编程调用接口（`API`），属于传输层（主要解决数据如何在网络中传输）

对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信

## upd

**UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。**

UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。

UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询---应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。

每个UDP报文分UDP报头和UDP数据区两部分。报头由**四个16位长**（2字节）字段组成，分别说明该报文的**源端口、目的端口、报文长度以及校验值**。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：

- （1）源端口号；
- （2）目标端口号；
- （3）数据报长度；
- （4）校验值。

**运输层提供应用进程之间的逻辑通信**，运输层之间的通信并不是真正在两个运输层之间直接传输数据。是端对端之间的应用进程传输



使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。

运输层的端口号分为服务器端使用的端口号（0˜1023 指派给熟知端口，1024˜49151 是登记端口号）和客户端暂时使用的端口号（49152˜65535）

## upd和tcp/ip协议的特点对比

UDP 的主要特点是 ① **无连接** ② 尽最大努力交付 ③ 面向报文 ④ 无拥塞控制 ⑤ 支持一对一，一对多，多对一和多对多的交互通信 ⑥ 首部开销小（只有四个字段：源端口，目的端口，长度和检验和）**upd是不可靠的**

TCP 的主要特点是 ① **面向连接** ② 每一条 TCP 连接只能是一对一的 ③ 提供**可靠**交付 ④ 提供全双工通信 ⑤ 面向字节流

## dns

DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，**可以简单地理解为将URL转换为IP地址**。**域名是由圆点分开一串单词或缩写组成的**，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。

我们可以通过windows的ping命令来查找域名所对应的ip地址

### dns解析

A记录:

```
定义www.example.com的ip地址
www.example.com.     IN     A     139.18.28.5;
```

`www.example.com` 是要解析的域名。

A 是记录的类型，A 记录代表着这是一条用于解析 IPv4 地址的记录。

从这条记录可知，`www.example.com`的 IP 地址是 139.18.28.5。

CNAME记录：

CNAME用于**定义域名的别名**，如下面这条 DNS 记录：

```
定义www.example.com的别名
a.example.com.          IN     CNAME   b.example.com.
```

这条 DNS 记录定义了 `a.example.com` 是 `b.example.com` 的别名。

用户在浏览器中输入 `a.example.com` 时候，通过 DNS 查询会知道 `a.example.com` 是 `b.example.com` 的别名，因此需要实际 IP 的时候，会去拿 `b.example.com` 的 A 记录。

当你想把一个网站迁移到新域名，旧域名仍然保留的时候；还有当你想将自己的静态资源放到 CDN 上的时候，CNAME 就非常有用。

AAAA记录：

A 记录是域名和 IPv4 地址的映射关系。和 A 记录类似，AAAA 记录则是域名和 IPv6 地址的映射关系。

MX记录：

MX 记录是邮件记录，用来描述邮件服务器的域名。

比如说，发送一封邮件到 `xiaoming@xiaoflyfish.com`，那么如何知道哪个 IP 地址是邮件服务器呢？

这个时候就可以用到下面这条 MX 记录：

```
IN MX mail.xiaoflyfish.com
```

`mail.xiaoflyfish.com` 的 IP 地址可以通过查询 `mail.xiaoflyfishcom `的 A 记录和 AAAA 记录获得。

NS记录：

NS记录是描述 DNS 服务器网址。从 DNS 的存储结构上说，Name Server 中含有权威 DNS 服务的目录。

也就是说，NS 记录指定哪台 Server 是回答 DNS 查询的权威域名服务器。

```
a.com.     IN      NS      ns1.a.com.
a.com.     IN      NS      ns2.a.com.
```

当解析 `a.com` 地址时，我们看到 `a.com` 有两个 NS 记录，所以确定最终 `a.com` 的记录在 `ns1.a.com` 和 `ns2.a.com` 上。

从设计上看，ns1 和 ns2 是网站 `a.com` 提供的智能 DNS 服务器，可以提供负载均衡、分布式 Sharding 等服务。

比如当一个北京的用户想要访问 `a.com` 的时候，ns1 看到这是一个北京的 IP 就返回一个离北京最近的机房 IP。

上面代码中 `a.com` 配置了两个 NS 记录。

通常 NS 不会只有一个，这是为了保证高可用，一个挂了另一个还能继续服务。

通常数字小的 NS 记录优先级更高，也就是 ns1 会优先于 ns2 响应。

配置了上面的 NS 记录后，如果还配置了 `a.com` 的 A 记录，那么这个 A 记录会被 NS 记录覆盖。

## nat

NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将**私有**（保留）地址转化为**合法IP地址**的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。

## dhcp

DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用**UDP协议工作**，主要有两个用途：**给内部网络或网络服务供应商自动分配IP地址**，**给用户或者内部网络管理员作为对所有计算机作中央管理的手段**。

## http

超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。

### 常见的http方法

**GET**：请求服务器返回指定的资源（例如网页）。是从服务器上获取资源，传送的数据量小，不能大于2kb。

**POST**：向服务器提交数据（例如表单数据）。向服务器提交资源，传送的数据量较大，一般默认为不受限制。

GET请求与Post请求区别：

1. GET 请求的请求参数是添加到 head 中，可以在 url 中可以看到；POST 请求的请求参数是添加到body中，在url 中不可见。
2. 请求的url有长度限制，这个限制由浏览器和 web 服务器决定和设置的，例如IE浏览器对 URL的最大限制为**2083**个字符（2kb），如果超过这个数字，提交按钮没有任何反应，因为GET请求的参数是添加到URL中，所以GET请求的URL的长度限制需要将请求参数长度也考虑进去。而POST请求不用考虑请求参数的长度。
3. **GET**请求产生**一个**数据包; **POST**请求产生**2个**数据包，在火狐浏览器中，产生一个数据包，这个区别点在于浏览器的请求机制，先发送请求头，再发送请求体，因为GET没有请求体，所以就发送一个数据包，而POST包含请求体，所以发送两次数据包，但是由于火狐机制不同，所以发送一个数据包。
4. GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
5. GET是幂等的，而POST不是(幂等表示执行相同的操作，结果也是相同的)
7. GET是获取数据，POST是修改数据

**PUT**：更新资源。

**DELETE**：删除资源。

**CONNECT**:HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。

**OPTIONS**:允许客户端查看服务器的性能。

**TRACE**:回显服务器收到的请求，主要用于测试或诊断。

**PATCH**:是对 PUT 方法的补充，用来对已知资源进行局部更新 。

根据http规范,get用于信息获取，应该是**安全的**和**幂等的**

- 所谓 **安全的** 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。
-  **幂等** 的意味着对同一URL的多个请求应该返回同样的结果。

### http状态码

状态码由三位数字构成，第一位定义响应的类别

**1xx**：代表成功表示请求以接收，继续处理

HTTP/1.1加入了一个新的状态码100。

客户端事先发送一个只带头域的请求，**如果服务器因为权限拒绝了请求，就回送响应码401**（Unauthorized）；

**如果服务器接收此请求就回送响应码100**，客户端就可以继续发送带实体的完整请求了。

100状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。

**2xx**：成功，表示请求已经被成功接收、理解、接受，例如 200 OK 表示请求成功。

- 200 OK 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
- 204 No Content 也是常见的成功状态码，与 200 OK 基本相同，**但响应头没有 body 数据。**
- 206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示**响应返回的 body 数据并不是资源的全部**，而是其中的一部分，也是服务器处理成功的状态。

**3xx**：重定向，例如 301 Moved Permanently 表示资源已永久移动。

- 301 Moved Permanently 表示**永久重定向**，说明请求的资源已经不存在了，需改用新的 URL 再次访问，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。

- 302 Moved Permanently 表示**临时重定向**，说明请求的资源还在，但暂时需要用另一个 URL 来访问，搜索引擎会抓取新的内容而保存旧的网址。

  301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

- 304 Not Modified不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称**缓存重定向**，用于缓存控制。

**4xx**：客户端发送的**报文有误**，例如 404 Not Found 表示请求的资源不存在。

- 400 Bad Request表示客户端请求的报文有错误。
- 401 Unauthorized：缺失或错误的认证，这个状态代码必须和WWW-Authenticate报头域一起使用。
- 403 Forbidden表示**服务器禁止访问资源**，并不是客户端的请求出错。
- 404 Not Found表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

**5xx**：状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，服务器错误，例如 500 Internal Server Error 表示服务器发生错误。

- 501 Not Implemented 表示客户端请求的功能还不支持。
- 502 Bad Gateway 通常是服务器作为**网关或代理**时返回的错误码，表示服务器自身工作正常，访问**后端服务器**发生了错误。
- 503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务器。
- 504 Gateway Timeout：**网关超时**，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。

### host字段

在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。

```
GET /index.html HTTP/1.0
```

HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

**服务器应当支持 Host 头字段**，用于处理多个虚拟主机共享同一 IP 地址的情况。

```
GET /index.html HTTP/1.1
Host: www.example.com
```

在这个请求中，`Host: www.example.com` 告诉服务器，该请求是针对 `www.example.com` 这个主机的，即便该服务器托管多个网站（如 `example.net`、`test.com`），它也可以正确解析请求。

此外，服务器应该接受以绝对路径标记的资源请求。

HTTP/1.1 允许请求中使用**绝对 URI（absolute URI）**，即完整 URL，包括协议、主机名和路径。例如：

```
GET http://www.example.com/index.html HTTP/1.1
Host: www.example.com
```



### https和http的区别

HTTPS 在 HTTP 上加入了 SSL/TLS 协议，通过**加密保护数据的机密性和完整性**，防止中间人攻击。

https更加安全，对搜索引擎更友好

其中http默认为80port，https默认443port

https基于**传输层**，http基于**应用层**

https在浏览器显示绿色安全锁，http则没有

### 请求报文

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-3c00598c-43c2-44cd-96c6-ee4d40b97abd.png)

HTTP 请求报文由3部分组成(请求行+请求头+请求体)

**常见的HTTP报文头属性**

- Accpet

  告诉服务端，客户端接收什么类型的响应

- Referer

  表示这是请求是从哪个URL进来的,比如想在网上购物，但是不知道选择哪家电商平台，你就去问度娘，说哪家电商的东西便宜啊，然后一堆东西弹出在你面前，第一给就是某宝，当你从这里进入某宝的时候，这个请求报文的Referer就是：[www.baidu.com](https://javabetter.cn/cs/www.baidu.com)

- Cache-Control

  对缓存进行控制，如一个请求希望响应的内容在客户端缓存一年，或不被缓可以通过这个报文头设置

- Accept-Encoding

  这个属性是用来告诉服务器能接受什么编码格式，包括字符编码,压缩形式(一般都是压缩形式)

  例如:`Accept-Encoding:gzip, deflate`(这两种都是压缩格式)

- Host

  指定要请求的资源所在的主机和端口

- User-Agent：告诉服务器，客户端使用的操作系统、浏览器版本和名称

- Connection

​	决定当前事务（三次握手和四次挥手）完成后，是否关闭网络连接。

- 持久连接，事务完成后不关闭网络连接 ：` Connection: keep-alive`

- 非持久连接，事务完成后关闭网络连接： `Connection: close`

### 响应报文

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/cs/wangluo-58884113-14dc-4cca-a63e-3320f31a4da5.png)

响应报文与请求报文一样，由三个部分组成(响应行,响应头,响应体)

- Cache-Control

  响应输出到客户端后，服务端通过该属性告诉客户端该怎么控制响应内容的缓存

- ETag

  表示你请求资源的版本，如果该资源发生啦变化，那么这个属性也会跟着变

- Location

  在重定向中或者创建新资源时使用

- Set-Cookie

  服务端可以设置客户端的cookie

## ssl/tls

SSL（Secure Sockets Layer，安全套接字层）和 TLS（Transport Layer Security，传输层安全协议）是用于**保障网络通信安全**的加密协议。TLS 是 SSL 的后续版本，TLS 1.0 基于 SSL 3.0 发展而来，目前**TLS 已经取代 SSL**，最新版本是 **TLS 1.3**。

作用：

**加密**：防止数据被窃听，确保传输的机密性。

**完整性**：防止数据被篡改，确保数据完整性。

**身份验证**：通过证书验证服务器（可选客户端）身份，防止中间人攻击。

### 工作流程

**客户端hello**

客户端向服务器发送 `ClientHello` 消息，包含：

- 支持的 TLS 版本（如 TLS 1.2、TLS 1.3）
- 支持的加密算法（如 AES、RSA、ECDHE 等）
- 一个随机数（用于后续密钥生成）

**服务器hello**

- 服务器响应 

  ```
  ServerHello
  ```

   消息，包含：

  - 选定的 TLS 版本和加密算法
  - 服务器证书（包含公钥）
  - 一个随机数

**密钥交换**：

- TLS 1.2 及更早版本：
  - 服务器的证书中包含公钥，客户端使用该公钥加密一个随机密钥并发送给服务器（RSA 密钥交换）。
  - 也可使用椭圆曲线 Diffie-Hellman（ECDHE）生成共享密钥。
- TLS 1.3（优化握手）：
  - 直接使用 ECDHE 进行密钥交换，减少握手步骤，提高安全性。

**证书验证：**

客户端验证服务器证书是否合法（CA 颁发、未过期等）。

可选地，服务器也可以要求客户端提供证书进行身份验证（双向 TLS）。

**对称密钥生成：**

双方根据交换的随机数和密钥交换算法，生成会话密钥。

后续数据通信使用 **对称加密算法**（如 AES）加密，提高效率。

**安全通信：**

双方交换 `Finished` 消息，表示握手完成。

之后所有通信数据都使用协商出的密钥进行加密传输。

**使用场景**

HTTPS（安全网站访问）

邮件加密（SMTP、IMAP、POP3）

VPN 连接

安全的消息传输（如 WhatsApp、Telegram）

## ftp

FTP（File Transfer Protocol，文件传输协议）是一种用于在网络上传输文件的协议。

FTP 允许用户从一台计算机（客户端）向另一台计算机（服务器）**上传或下载文件**。

流程：

- 客户端连接到服务器的 **21** 端口（默认的控制连接端口）。
- 服务器返回状态码 220，表示服务已就绪。
- 客户端发送用户名（USER 命令），服务器返回 331，表示需要密码。
- 客户端发送密码（PASS 命令），服务器返回 230，表示登录成功。

文件传输分为两个模式

一个是主动模式:服务器主动连接到客户端的数据端口。

- 客户端发送 PORT 命令，告知服务器自己的 IP 地址和数据端口。
- 服务器连接到客户端的数据端口，开始传输文件。

另一个是被动模式：客户端连接到服务器的数据端口。

- 客户端发送 **PASV** 命令，请求进入被动模式。
- 服务器返回自己的 IP 地址和数据端口。
- 客户端连接到服务器的数据端口，开始传输文件。

ftp自己本身是并不安全的，因为传输过程中使用明文传输用户名和密码等，所以出现了替代品

- **SFTP**：基于 SSH 的文件传输协议，加密传输数据。
- **FTPS**：基于 SSL/TLS 的 FTP，加密传输数据。

## ssh

SSH（Secure Shell，安全外壳协议）是一种用于安全远程登录和其他网络服务的加密协议。

SSH 通过加密通信来保护数据在传输过程中的安全性，广泛应用于系统管理、文件传输和远程命令执行等场景。

流程：

- 客户端连接到服务器的 **22** 端口（默认的 SSH 端口）。
- 服务器发送自己的公钥给客户端。
- 客户端验证服务器公钥（通常通过已知的主机密钥指纹）。
- 客户端和服务器协商加密算法（如 AES、RSA 等）。
- 客户端生成一个会话密钥，用服务器的公钥加密后发送给服务器。
- 双方使用会话密钥加密后续通信。

## smtp

SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一种用于发送电子邮件的网络协议。

SMTP 是互联网上电子邮件传输的核心协议之一，负责将邮件从发送方传递到接收方的邮件服务器。

**发送邮件和传递邮件**

连接建立：

- 户端连接到服务器的 25 端口（默认的 SMTP 端口）。
- 服务器返回状态码 220，表示服务已就绪。
- 客户端发送 HELO 或 EHLO 命令，告知服务器自己的域名。
- 服务器返回状态码 250，表示命令成功。

smtp本身也是不安全的，因为使用过程中也是使用明文传输。可以使用下面的来代替

- **STARTTLS**：将明文连接升级为加密连接，使用 TLS/SSL 加密数据。
- **SMTP AUTH**：通过身份验证机制（如 PLAIN、LOGIN）验证用户身份。

## 数字签名

网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改

数字签名校验数据的完整性

数字签名有两种功效：

- 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。
- 数字签名能确定消息的完整性，证明数据是否未被篡改过。

将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者

接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。

如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。

## cookie和session

Session 是**基于Cookie 实现**的另一种记录服务端和客户端会话状态的机制。

Session 是存储在服务端，而 SessionId 会被存储在客户端的 Cookie 中。

Session的认证过程：

1. 客户端第一次发送请求到服务端，服务端根据信息创建对应的 Session，并在响应头返回 SessionID
2. 客户端接收到服务端返回的 SessionID 后，会将此信息存储在 Cookie 上，同时会记录这个 SessionID 属于哪个域名
3. 当客户端再次访问服务端时，请求会自动判断该域名下是否存在 Cookie 信息，如果有则发送给服务端，服务端会从 Cookie 中拿到 SessionID，再根据 SessionID 找到对应的 Session，如果有对应的 Session 则通过，继续执行请求，否则就中断

**Cookie和Session的区别**

1. 安全性，因为 Cookie 可以通过客户端修改，而 Session 只能在服务端设置，所以安全性比 Cookie 高，一般会用于验证用户登录状态
2. 适用性，Cookie 只能存储字符串数据，而 Session 可以存储任意类型数据
3. 有效期，Cookie 可以设置任意时间有效，而 Session 一般失效时间短
