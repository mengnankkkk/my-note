---
title: 计算机网络重要问题总结
categories:
  - 408
abbrlink: 2708
date: 2025.3.6
tags:
   - net
   - 面试
---

# 基础

## 1.说下计算机网络体系结构

计算机网络体系结构通过复杂的网络通信分为不同的层次，来实现交互化的目的。常见的模型分为OSI七层模型，tcp/ip四层模型和五层体系结构

OSI是理论上的网络通信模型，TCP/IP是实际应用层面的网络通信模型，五层结构是为了方便理解和记忆

**OSI七层模型**是一个网络架构模型，由国际标准化祖师提出，用于描述和标准化各种计算机网络的功能和过程。这七层分别是
应用层：最靠近用户的层，负责处理特定的应用程序细节。这一层提供了网络服务和用户应用软件之间的接口，例如web浏览器,ftp客户端和服务器，电子邮件客户端等等。

表示层：**确保一个系统发送的信息可以被另一个系统的应用层读取**。负责数据的转换压缩和加密。例如，确保数据从一种编码格式转换为另一种。ASCII->EBCDIC

会话层:管理用户的会话，空网络上两节点之间的对话和数据交换的管理。负责建立维护和终止会话。例如建立一个回鹘令牌，以便在网络上两个节点进行传递。

传输层：提供**端到端**的通信服务，保证数据的完整性和正确顺序。这一层包括TCP和UDP等。

网络层：负责在多个网络之间进行数据传输，确保数据能够在复杂的网络结构中找到源到目的地的最佳路径，这层使用的是IP协议

数据链路层：在物理连接中提供可靠的**传输**，负责建立和维护两个相邻节点的链路。包括帧同步,MAC

物理层:负责在**物理媒介**上实现原始的数据传输，比如电缆光缆和无线信号传输。涉及的内容包括电压，接口，针脚，电缆的规格和传输速率等。

**TCP/IP协议四层模型**是互联网通信的核心，定义了一系列协议和标准，确保设备间可以可靠地进行数据传输。

应用层：直接面向用户和应用程序，提供各种网络服务。它包含了用于**特定应用的协议和服务**，如 HTTP（HyperText Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）等。

传输层：提供**端到端**的通信服务，确保数据可靠传输。它负责分段数据、流量控制、错误检测和纠正。常见的传输层协议有 TCP 和 UDP。

网络层：负责在不同网络之间路由数据包，提供逻辑地址（IP 地址）和网络寻址功能。用于处理数据包的分组、转发和路由选择，确保数据可以从源端传输到目标端。

网络接口层：负责将数字信号在物理通道（网线）中准确传输，定义了如何在单一网络链路上传输数据，如何处理数据帧的发送和接收，包括物理地址（MAC 地址）的解析。

**五层结构体系**

对 OSI 和 TCP/IP 的折衷，它保留了 TCP/IP 的实用性，同时提供了比四层模型更细致的分层，便于教学和理解网络的各个方面。

- 应用层：作为网络服务和最终用户之间的接口。它提供了一系列供应用程序使用的协议，如 HTTP（网页）、FTP（文件传输）、SMTP（邮件传输）等。使用户的应用程序可以访问网络服务。
- 传输层：提供进程到进程的通信管理，这一层确保数据按顺序、无错误地传输。主要协议包括 TCP 和 UDP。
- 网络层：负责数据包从源到目的地的传输和路由选择，包括跨越多个网络（即互联网）。它使用逻辑地址（如 IP 地址）来唯一标识设备。路由器是网络层设备。
- 数据链路层：确保从一个节点到另一个节点的可靠、有效的数据传输。交换机、网桥是数据链路层设备。
- 物理层：电缆、光纤、无线电频谱、网络适配器等

TCP的三次握手和四次挥手在哪一层？

三次握手和四次挥手都是工作在**传输层**。传输层（Transport Layer）是 OSI 模型的第四层，负责提供端到端的通信服务，包括数据传输的建立、维护和终止。

TCP作为一种面向连接的协议，通过三次握手建立连接，通过四次挥手终止连接，确保数据传输的可靠性和完整性。

将一下计算机网络？

计算机网络是指将多台计算机通过**通信设备**互联起来，实现资源共享和信息传递的系统。

## 2.说一下每层对应的网络协议有哪些

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-ad64bbac-e0d5-4286-9b77-d008e8c8d419.jpg)

## 3.数据在各层之中时怎么传输的

对发送方而言，从上层到下层层层包装，对于接受方来说，从下层到上层层层解开包装。

- 发送方的应用进程向接受方的应用进程传送数据
- AP 先将数据交给本主机的**应用层**，应用层加上本层的控制信息 H5 就变成了下一层的数据单元
- 传输层收到这个数据单元后，加上本层的控制信息 H4，再交给网络层，成为网络层的数据单元
- 到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）
- 最后的物理层，进行比特流的传输

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-6e4a8326-992c-442a-8265-5dc3d179b689.jpg)

# 网络综合

## 4.从浏览器地址栏输入url到显示网页的过程

过程包括多个步骤，涵盖了 DNS 解析、TCP 连接、发送 HTTP 请求、服务器处理请求并返回 HTTP 响应、浏览器处理响应并渲染页面等多个环节。

1. **DNS 解析**：浏览器会发起一个 DNS 请求到 DNS 服务器，将**域名解析为服务器的 IP 地址**。
2. **TCP 连接**：浏览器通过解析得到的 IP 地址与服务器建立 TCP 连接。这一步涉及到 TCP 的三次握手，用于确保双方都已经准备好进行数据传输了。
3. **发送 HTTP 请求**：浏览器构建 HTTP 请求，包括请求行、请求头和请求体；然后将请求发送到服务器。
4. **服务器处理请求**：服务器接收到 HTTP 请求后，根据请求的资源路径，经过后端处理，生成 HTTP 响应消息；响应消息包括状态行、响应头和响应体。
5. **浏览器接收 HTTP 响应**：浏览器接收到服务器返回的 HTTP 响应数据后，开始解析响应体中的 HTML 内容；然后构建 DOM 树、解析 CSS 和 JavaScript 文件等，最终渲染页面。
6. **断开连接**：TCP 四次挥手，连接结束

各个过程用了哪些协议：

DNS解析：DNS协议

剩下的步骤：TCP协议，IP协议，OPSF协议

ARP协议，HTTP协议

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-f5ff6e46-4524-4594-b294-56a23c366df9.jpg)

## 5.DNS解析的过程

DNS是域名解析系统，可以将域名映射到对应的IP地址上，

比如说我们访问 www.tokenlen.top，实际上访问的是我在阿里云上一台丐版服务器，它的 IP 地址是 xxx.xxx.xxx.xxx。

当然也可以直接使用IP地址来访问，但是IP地址不太好记。

域名到IP的映射就需要DNS来完成

DNS解析过程：

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-03408af8-3ca8-49bd-9244-6afa6fe132c6.jpg)

## 6.webSOCKET和Socket的区别

Socket=IP+端口+协议

是一套标准，完成了对TCP/IP的高度封装，屏蔽网络细节，以便更好的网络编程

webSocket是一个持久化的协议，伴随H5而出的协议，用来解决

http不支持持久化连接的问题

Socket是一个**网络编程的标准接口**，webSocket则是**应用层通信协议**

## 7.常见的端口及其对应的服务

port           server

21			ftp

22			ssh

23 			telent

53			dns

80			http

443			https

1080			sockets

3306			mysql

5524			alist

8080			测试端口

# HTTP

## 8.http常用的状态码及其意义

1xx：成功，需要进一步操作,100 continue

2xx:成功，200ok完成 204缺少一部分body

3xx:重定向 301 永久重定向,302临时重定向

4xx:客户端有问题,404资源不存在，403没有权限访问

5xx:服务器有问题，500服务器内部问题，502网关或者代理出了问题，504网关超时

## 9.http请求

get：获取数据，是幂等的，不能发送太多，限制2kb

post:提交数据，不是幂等的，发送一般不限制

delete:删除指定的资源

put:更新指定的资源

herd:类似get请求，返回响应中没有具体的内容，获取报头。用于检查资源资源是否存在，验证资源的更新时间等等

options:获取服务器支持的Http方法

trace:回显服务器收到的请求，用于测试

connect:建立一个到目标资源的隧道，用于客户端和服务器之间进行加密的隧道传输。

## 10.get和post请求的区别

get主要用于获取数据，参数附加在url栏中，存在长度限制,2kb，这个长度限制不是url的限制而是服务器的限制，是针对整个url的限制，而不是对数据部分的限制，容易被浏览器缓存，有安全风险，post用于提交数据，参数放在请求体中,适合提交大量或者敏感的数据。

get请求是幂等的，多次提交不会改变服务器状态，post请求不是幂等的，可能会对服务器数据有影响。

## 11.http请求的过程和原理

http是基于tcp/ip协议的应用层协议，使用tcp作为传输层协议，通过建立tcp连接来传输数据

http遵循标准的客户端-服务器模型，客户端打开连接发出请求，然后等待服务器返回的响应

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-9a1a42b7-c14a-43d8-b8d8-f1f18c9b923b.jpg)

- 在浏览器输入 URL 后，浏览器首先会通过 DNS 解析获取到服务器的 IP 地址，然后与服务器建立 TCP 连接。
- TCP 连接建立后，浏览器会向服务器发送 HTTP 请求。
- 服务器收到请求后，会根据请求的信息处理请求。
- 处理完请求后，服务器会返回一个 HTTP 响应给浏览器。
- 浏览器收到响应后，会根据响应的信息渲染页面。然后，浏览器和服务器断开 TCP 连接。

客户端发送一个请求到服务器，服务器处理请求并返回一个响应。这个过程是同步的，也就是说，**客户端在发送请求后必须等待服务器的响应。在等待响应的过程中，客户端不会发送其他请求。**

利用多线程来下载一个数据

可以采用分块下载的策略，首先使用head来获取文件的总大小，然后根据文件大小和线程数，将文件进行切割，每个线程负责下载一个特定范围的数据

可以通过设置http请求头的range字段指定下载的字节区间

例如，`Range: bytes=0-1023` 表示下载文件的前 1024 字节。

最后启动多线程下载。

## 12.http的报文结构

http的报文结构分为请求报文和响应报文

都包含了起始行，头部，和消息正文

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-2ea62914-e1ed-418c-9580-e13ecf7b8992.jpg)

请求报文：

请求报文由请求行，请求头部，空行和消息正文组成

```
GET /index.html HTTP/1.1
Host: www.javabetter.cn
Accept: text/html
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3
```

GET /index.html HTTP/1.1请求行，包括请求url和http协议的版本

请求头部包含请求的附加信息：

- `Host: www.javabetter.cn`，表示请求的主机名（域名）
- `Accept: text/html`，表示客户端可以接收的媒体类型
- `User-Agent: Mozilla/5.0`，表示客户端的浏览器类型
- Range：用于指定请求内容的范围，如断点续传时表示请求的字节范围。

请求头部和消息正文之间有一个空行，表示请求头部结束

消息正文是可选的，如post请求中的表单数据，get请求没有正文

响应报文：

```
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84
<html>
  <body>mengnankk</body>
</html>
```

状态行：包括http协议的方法，状态码，和消息状态

响应头部：

- `Content-Type: text/plain`，表示响应的内容类型
- `Content-Length: 137582`，表示响应的内容长度
- `Expires: Thu, 05 Dec 1997 16:00:00 GMT`，表示资源的过期时间
- `Last-Modified: Wed, 5 August 1996 15:55:28 GMT`，表示资源的最后修改时间
- `Server: Apache 0.84`，表示服务器类型

空行：表示响应头部结束

消息正文：响应的具体内容，例如html界面，不是所有的响应都有正文消息，例如204(没有响应中的body)

## 13.url和uri有什么区别

URI：统一资源标识符(Uniform Resource Identifier， URI)，标识的是 Web **上每一种可用的资源**，如 HTML 文档、图像、视频片段、程序等都是由一个 URI 进行标识的。

URL：统一资源定位符（Uniform Resource Location），它是 URI 的一种子集，主要作用是**提供资源的路径。**

URL **除了提供了资源的标识，还提供了资源访问的方式**。这么比喻，URI 像是身份证，可以唯一标识一个人，而 URL 更像一个住址，可以通过 URL 找到这个人——人类住址协议://地球/中国/北京市/海淀区/xx 职业技术学院/14 号宿舍楼/525 号寝/张三.男。

## 15.http长连接

在Http中，长连接是指客户端和服务器在完成一次http通信后，连接不会立即断开，而是保留连接以供后序使用

这种机制可以减少了频繁建立和关闭连接的开销

设置长连接：通过 **Connection: keep-alive** 实现。在 HTTP/1.1 中，长连接是默认开启的。

超时：

http一般会有httpd守护进程，里面可以设置keep-alive timeout，当tcp连接闲置超过这个时间就会关闭，也可以在http里的header里设置超时时间

TCP 的 **keep-alive** 包含三个参数，支持在系统内核的 net.ipv4 里面设置；当 TCP 连接之后，闲置了 **tcp_keepalive_time**，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了 **tcp_keepalive_probes**，就会丢弃该连接。

```
1. tcp_keepalive_intvl = 15
2. tcp_keepalive_probes = 5
3. tcp_keepalive_time = 1800
```

## 16.http和https的区别

https是http的增强版，是在http的基础上加入了ssl/tls协议，确保数据在传输过程中是加密的

http的默认端口是80,url以http://开头,https默认端口是443,url以https://开头

https基于**传输层**，http基于**应用层**

https在浏览器显示绿色安全锁，http则没有

## 17.https连接的建立过程

![](https://cdn.tobebetterjavaer.com/stutymore/network-20240418124713.png)

1. 客户端向服务器发送请求
2. 服务器接收到请求后，返回自己的数字证书，包含了公匙，颁发机构等
3. 客户端接收到服务器的证书后，验证证书的合法性，如果合法，会生成一个随机码，然后用服务器的公匙加密整个随机码，然后发送给服务器
4. 服务器收到会话密钥后，用私钥解密，得到会话密钥
5. 客户端和服务器通过会吗密码对通信内容进行加密，然后传输

通信内容被截取，没有会话密钥，无法解密。新的连接建立后，生成的密钥是新的

**url会被https加密吗？**

https会加密url，因为url是http头部的一部分。但是完整的url可能会在web服务器的日志中记录，浏览器中也是可以看到的。所以敏感信息不应该通过url来传输

**中间人攻击**？

攻击者可以在通信的两端插入自己，以窃取通信双方的信息。

中间人攻击是一个**缺乏相互认证**的攻击，因此大多数加密协议都会专门加入一些特殊的认证方法，以防止中间人攻击。像 SSL 协议，就是通过验证服务器的数字证书，是否由 CA（权威的受信任的数字证书认证机构）签发，来防止中间人攻击的

**http如何保证建立的信道是安全的？**

通过 SSL/TLS 协议的多层次安全机制，首先在握手阶段，客户端和服务器使用得是非对称加密，生成的会话密钥只**有服务器的私钥**才能解密，而私钥只有服务器持有。

## 18.如何理解http是无状态的

http协议是无状态的，表明每个http请求都是**独立**的，服务器不会保留任何关于**客户端请求的历史信息**

- 每个 HTTP 请求都包含了所必须的信息，服务器在处理当前请求时，不依赖于之前的任何请求信息。
- 服务器不会记录任何客户端请求的状态，每次请求都像是第一次与服务器通信。

维持记录状态

cookies：服务器通过 Set-Cookie 响应头将状态信息存储在客户端，客户端在后续请求中发送该 Cookie 以维持状态。

session：服务器生成一个唯一的会话 ID，存储在 Cookie 中，并在服务器端维护与该会话 ID 关联的状态信息。

token：使用 JWT（JSON Web Token）等机制在客户端存储状态信息，客户端在每次请求中发送该 Token。

# tcp

## 19.详细说一下tcp的三次握手机制

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-a6c0457e-544e-4291-98d9-862fc6a18631.jpg)

第一次握手：客户端将TCP报文标志位`SYN`置为1，随机产生一个序号值`seq=J`，保存在TCP首部的序列号字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入`SYN_SENT`状态，等待服务器端确认。

第二次握手：服务器端收到数据包后由标志位`SYN=1`知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，`ack=J+1`，随机产生一个序号值`seq=K`，并将该数据包发送给客户端以确认连接请求，服务器端进入`SYN_RCVD`状态。

服务器第一次收到客户端的 SYN 之后，就会处于 `SYN_RCVD`状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为**半连接队列**。

服务器发送完**SYN－ACK**包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的**最大重传次数**，系统将该连接信息从**半连接队列**中删除。

第三次握手：客户端收到确认后，检查ack是否为`J+1`，ACK是否为1，如果正确则将标志位ACK置为1，`ack=K+1`，并将该数据包发送给服务器端，服务器端检查ack是否为`K+1`，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入`ESTABLISHED`状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。

**全连接队列**就是三次握手已经完成了，建立起的连接就会放到全连接队列里，队列满了就会出现丢包。

其实第三次握手的时候，是可以携带数据的，也就是说，第一次、第二次握手不可以携带数据，而**第三次握手是可以携带数据**的。

其中上面的ack和ACK不是同一个概念

- 小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，`ack=seq+1`。
- 大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。

**说说SYN的概念**

SYN是TCP 协议中用来建立连接的一个标志位，全称为 Synchronize Sequence Numbers，也就是同步序列编号。

不仅确保了序列号的同步，使得后续的数据能够有序传输，还能防止旧的报文段被误认为是新连接。

**泛洪攻击**

是一种常见的 DoS（拒绝服务）攻击，攻击者会发送大量的伪造的 TCP 连接请求，导致服务器资源耗尽，无法处理正常的连接请求。

半连接服务拒绝，也称为 SYN 洪泛攻击或 SYN Flood。

所谓的半连接就是指在 TCP 的三次握手过程中，当服务器接收到来自客户端的第一个 SYN 包后，它会回复一个 SYN-ACK 包，此时连接处于“半开”状态，因为连接的建立还需要客户端发送最后一个 ACK 包。

在收到最后的 ACK 包之前，服务器会为这个尚未完成的连接分配一定的资源，并在它的队列中保留这个连接的位置。



解决方法：

重新设计 TCP 的连接建立过程，可以考虑引入 SYN cookies，这种技术通过在 SYN-ACK 响应中编码连接信息，从而在不占用大量资源的情况下验证客户端。

## 20.tcp握手为什么是三次？

使用三次握手可以建立一个可靠的连接，确保双方都知道对方已经准备好通信，同步双方的序列号，保证数据包的顺序和完整。

为什么不能是两次？

- 防止客户端一直在等待
- 防止客户端已经将失效的连接请求传输到服务器

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-ad16baac-f8fa-4fb1-a459-8a98e4db85ca.jpg)

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-4209349f-b80c-4387-8461-c6ecd0e2129b.jpg)

## 21.三次握手中每一次没收到报文会发生什么情况

第一次：第一次握手服务端未收到 SYN 报文

服务器不会进行任何的动作，如果客户端没收到发来的SYN-ACK包的话，等待一段时间后，会重新发送SYN报文，如果仍然没有回复，会重复这个过程。知道发送次数超过最大重传次数之后，返回连接建立失败。

第二次：第二次握手客户端未收到服务端响应的 ACK 报文

客户端会继续重传，服务端会阻塞在accpet()处，等待客户端发送ACK报文

第三次：第三次握手服务端为收到客户端发送过来的 ACK 报文

服务器同样会采用类似客户端的超时重传机制，如果重试次数超过限制，则 accept()调用返回-1，服务端建立连接失败；而此时客户端认为自己已经建立连接成功，因此开始向服务端发送数据，但是服务端的 accept()系统调用已经返回，此时不在监听状态，因此服务端接收到客户端发送来的数据时会发送 RST 报文给客户端，消除客户端单方面建立连接的状态。

## 22.第二次握手回传了ACK为什么还要传回SYN

ACK是为了告诉客户端传输的数据已经接受无误

SYN是为了告诉客户端，服务器响应的确实是客户端发送的报文。

## 23.TCP半连接

TCP 半连接指的是在 TCP 三次握手过程中，服务器接收到了客户端的 SYN 包，但还没有完成第三次握手，此时的连接处于一种未完全建立的状态。

就是第二次握手完成后，但是第三次握手还没完成

如果服务器回复了 SYN-ACK，但客户端还没有回复 ACK，该连接将一直保留在半连接队列中，直到超时或被拒绝。

**半连接队列**

TCP 进入三次握手前，服务端会从 **CLOSED** 状态变为 **LISTEN** 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-f95c3cbb-cf2d-4444-9878-44ec076beb86.jpg)

顾名思义，半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接。

- TCP 三次握手时，客户端发送 SYN 到服务端，服务端收到之后，便回复 **ACK 和 SYN**，状态由 **LISTEN 变为 SYN_RCVD**，此时这个连接就被推入了 **SYN 队列**，即半连接队列。
- 当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即全连接队列。

**SYN FLood**

SYN Flood 是一种典型的 DDos 攻击，它在短时间内，伪造**不存在的 IP 地址**, 向服务器发送大量 SYN 报文。当服务器回复 SYN+ACK 报文后，不会收到 ACK 回应报文，那么 SYN 队列里的连接旧不会出对队，久⽽久之就会占满服务端的 **SYN** 接收队列（半连接队列），使得服务器不能为正常⽤户服务。

应对方案：

主要有 **syn cookie** 和 **SYN Proxy 防火墙**等。

- **syn cookie**：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。
- **SYN Proxy 防火墙**：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。

## 24.TCP四次挥手的过程

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-ba156295-03af-46dc-8ef3-869b44b11303.jpg)

第一次挥手：客户端向服务器发送一个FIN结束报文，表示客户端没有数据可以发送了，但仍然可以接受数据，客户端进入FIN-WAIT-1状态

第二次挥手：服务器接受到FIN报文后，向客户端发送一个ACK报文，表示已经接受到客户端的FIN请求，服务器进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态

第三次挥手：服务器向客户端发送一个FIN请求，表示服务器也没有数据要发送了，服务器进入LAST-ACK状态

第四次挥手：客户端接收到FIN报文后，向服务器发送一个ACK请求，确认已经接受到服务器的FIN请求，客户端进入TIME-WAIT状态，等等一段时间后确保服务器接受到ACK请求，服务器收到ACK报文后进入CLOSE状态，客户端等待一段时间（2MSL）后进入CLOSE状态。

## 25.为什么需要挥手四次

 TCP 是**全双工通信协议**，数据的发送和接收需要两次**一来一回**，也就是四次，**来确保双方都能正确关闭连接**。

**MSL**：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。

 **为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。** 这个 ACK 报文段有可能丢失，因而使处在 **LAST-ACK** 状态的服务端就收不到对已发送的 **FIN + ACK** 报文段的确认。服务端会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（**超时 + 1MSL 传输**）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 **CLOSED** 状态。

**2. 防止已失效的连接请求报文段出现在本连接中**。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。

等待 2 倍的 MSL，⽐较合理的解释是：**⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应**，所以⼀来⼀回需要等待 **2** 倍的时间。

## 26.保活计时器有什么用

除去时间等待器以外，TCP 还有一个保活计时器（keepalive timer）。

服务器每收到一次客户端的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。

简单点理解就是检测客户端是否存活的一个计时器，设定好时间。

## 27.close-wait和time-wait的状态和意义

close-wait：

服务端收到客户端关闭连接的请求并确认之后，就会进入 CLOSE-WAIT 状态。此时服务端可能还有一些数据没有传输完成，因此不能立即关闭连接，而 CLOSE-WAIT 状态就是为了**保证服务端在关闭连接之前将待发送的数据处理完。**

time-wait：

time-wait发生在第四次挥手，当客户端在发送 ACK 确认对方的 FIN 报文后，会进入 TIME_WAIT 状态。

- 在 TIME_WAIT 状态中，客户端可以重新发送 ACK 确保对方正常关闭连接。
- 在 TIME_WAIT 持续的 **2MSL** 时间后，确保旧数据包完全消失，避免它们干扰未来建立的新连接。

## 28.time-wait状态过多会导致什么问题

如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器⽅主动发起的断开请求。

过多的time-wait有两种危害：

一是内存资源占⽤；

第⼆是对端⼝资源的占⽤，⼀个 TCP 连接⾄少消耗⼀个本地端⼝；

如何解决：

- 服务器可以设置 **SO_REUSEADDR** 套接字来通知内核，如果端口被占用，但是 TCP 连接位于 TIME_WAIT 状态时可以重用端口。
- 还可以使用长连接的方式来减少 TCP 的连接和断开，在长连接的业务里往往不需要考虑 TIME_WAIT 状态。

## 30.tcp报文头部的格式

TCP 报文段主要由报文段头部（Header）和数据两部分组成。头部包含了确保数据可靠传输所需的各种控制信息，比如说序列号、确认号、窗口大小等。

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/nice-article/weixin-mianznxjsjwllsewswztwxxssc-f74d2a4f-b91e-4d8c-9fe7-6b670d818aed.jpg)

- **源端口号**（Source Port）：16 位（2 个字节），用于标识发送端的应用程序。
- **目标端口号**（Destination Port）：也是 16 位，用于标识接收端的应用程序。
- **序列号**（Sequence Number）：32 位，用于标识从 TCP 发送者发送的数据字节流中的第一个字节的顺序号。确保数据按顺序接收。
- **确认号**（Acknowledgment Number）：32 位，如果 ACK 标志被设置，则该字段包含发送确认的序列号，即接收 TCP 希望收到的下一个序列号。
- **数据偏移**（Data Offset）：4 位，表示 TCP 报文头部的长度，用于指示数据开始的位置。
- **保留**（Reserved）：6 位，为将来使用预留，目前必须置为 0。
- **控制位**（Flags）：共 6 位，包括 URG（紧急指针字段是否有效）、ACK（确认字段是否有效）、PSH（提示接收端应该尽快将这个报文段交给应用层）、RST（重置连接）、SYN（同步序号，用于建立连接）、FIN（结束发送数据）。
- **窗口大小**（Window）：16 位，用于流量控制，表示接收端还能接收的数据的字节数（基于接收缓冲区的大小）。
- **校验和**（Checksum）：16 位，覆盖整个 TCP 报文段（包括 TCP 头部、数据和一个伪头部）的校验和，用于检测数据在传输过程中的任何变化。
- **紧急指针**（Urgent Pointer）：16 位，只有当 URG 控制位被设置时才有效，指出在报文段中有紧急数据的位置。

## 31.tcp为什么是可靠的

首先通过**三次握手**和**四次挥手**来保证连接的可靠性，然后通过校验和、序列号、确认应答、超时重传、滑动窗口等机制来保证数据的可靠传输。

校验和：

TCP 报文段包括一个校验和字段，用于检测报文段在传输过程中的变化。如果接收方检测到校验和错误，就会丢弃这个报文段。

序列号:

TCP 将数据分成多个小段，每段数据都有唯一的序列号，以确保数据包的顺序传输和完整性。同时，发送方如果没有收到接收方的确认应答，会重传数据。

流量控制：

接收方会发送窗口大小告诉发送方它的接收能力。发送方会根据窗口大小调整发送速度，避免网络拥塞。

超时重传：

如果发送方发送的数据包超过了最大生存时间，接收方还没有收到，发送方会重传数据包以保证丢失数据重新传输。

拥塞控制：

TCP 会采用慢启动的策略，**一开始发的少，然后逐步增加**，当检测到网络拥塞时，会降低发送速率。在网络拥塞缓解后，传输速率也会自动恢复。

