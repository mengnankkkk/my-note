---
title: redis面试hot
categories:
  - 技术栈
  
abbrlink: 2701
date: 2025.5.15
tags: 
   - redis
   - 面试
---

# 基础

## 1.详细的说说Redis的数据类型

redis中常用的五种数据结构：**string、list、set、zset、hash**。

String结构底层是**一个简单动态字符串**，支持扩容，存储字符串。所以可应用于微信文章的阅读数或点赞

list存储**线性有序且可重复的元素**，底层数据结构可以是双向链表/压缩列表。微薄的粉丝列表或好友列表

set存**储不可重复的元素**，一般用于求交集、差集等，底层数据结构可以是hash和整数数组，所以可应用于抽奖，通过sadd添加不同的用户，srandom key number选出中将用户。还有集合的运算：sdiff、sintern与sunio就是集合的差交并运算，所以可应用于QQ的共同好友

zset存储的**是有序不可重复的元素**，zset为每个元素添加了一个score属性作为排序依据，底层数据结构可以是ziplist和跳表，所以可应用于排行榜，类似于微博热搜

hash类型存储的**是键值对**，底层数据结构是ziplist和hash。redis会在性能以及节省内存间考虑，选择最适合当前状态的底层数据结构实现  可用于存储用户数据，一个key代表一个用户，feild表示用户的各个属性，然后对应的value就是属性对应的值

list(有序可重复) 底层数据结构是双向链表/压缩链表

set(不可重复) = hash + 整数数组

zset(有序不可重复)ziplist+hashtable

hash(键值对) = ziplist+hash

还有四种特殊的数据类型

bitmaps：通过位操作（0/1）高效存储布尔型数据，基于 String 实现 

不是重复的，有序，按照顺序排列

- 用户签到（记录每天是否签到）
- 活跃用户统计（是否活跃为 1，不活跃为 0）
- 商品浏览记录等布尔型状态场景

hyperloglog：基于概率算法，**用于估算唯一元素的数量**，内存占用极小（仅 12KB 即可处理百万级数据）。误差极小。基于 HyperLogLog 算法（稀疏和稠密表示）是自动去重的无序的数据

- 网站 UV（独立访客统计
- 统计某活动中多少人参与（去重计数）
- 分布式唯一用户识别

geospatial：存储经纬度信息，支持距离计算、范围查询。基于 **zset（跳表 + 哈希）** 实现 不是重复的，按照地理位置的score排序

- 附近商家/门店搜索（附近 1 公里内）
- 地图打车服务（距离计算）
- 地理围栏功能

stream：Redis 的消息队列系统，**支持多消费者组、消费确认、消息持久化等特性**，功能类似 Kafka。底层类似日志结构（追加写），内部由 radix tree + linked list 组织 消息id唯一，但内容可重复。按照消息id排序

- 事件驱动架构（Event Sourcing）
- 用户行为日志收集
- 异步任务队列（如发送通知、消息推送）

| 类型            | 底层结构              | 是否有序         | 是否允许重复 | 典型应用                     |
| --------------- | --------------------- | ---------------- | ------------ | ---------------------------- |
| String          | 简单动态字符串        | 无               | 是           | 点赞数、token、配置缓存等    |
| List            | 双向链表 / 压缩列表   | 有               | 是           | 消息列表、任务队列、评论     |
| Set             | 哈希表 / 整数数组     | 无               | 否           | 抽奖、标签、共同好友         |
| ZSet            | 跳表 / ziplist        | 有（score 排序） | 否           | 排行榜、热搜榜               |
| Hash            | ziplist / 哈希表      | 无               | key 不重复   | 用户信息、配置表             |
| **Bitmaps**     | String + 位运算       | 有（按位）       | 否           | 签到、活跃状态、开关位标志   |
| **HyperLogLog** | 概率结构（哈希桶）    | 无               | 自动去重     | UV 去重、唯一值估算          |
| **Geo**         | 基于 ZSet + GeoHash   | 有（按位置编码） | 否           | 附近位置查找、LBS、导航定位  |
| **Stream**      | 日志结构 + radix tree | 有（消息 ID）    | 内容可重复   | 消息队列、日志收集、事件通知 |

## 2.说说Redis的单线程架构。

redis采用的是**单线程+IO多路复用技术**。这里单线程指的是**redis中读写操作和网络IO使用的是是有一个线程来完成**，但是其他操作是有其他线程完成，例如持久化操作。单线程既**可以简化数据结构和算法的实现，同时也消除了线程切换和锁竞争所带来的消耗**。redis中采用的IO多路复用技术实现了**单线程下同时处理多个IO请求**。

redis为什么这么快：

1.单线程进行读写操作，避免线程切换和锁竞争带来的消耗。

2：redis操作是在内存中进行的。

3.最重要的就是：采用了IO多路复用技术，实现了在网络IO中能够处理大量并发请求，实现高吞吐率。

## 3.说说Redis的持久化策略。

redis的持久化策略有三种：

1.RDB持久化：将当前进程中的数据已生成**快照**的方式保存到硬盘中，是redis默认的持久化机制。优点：持久化时生成的文件体积小，恢复数据快，缺点：每次运行都需要执行fork操作，RDB持久化策略，**没有做到实时的持久化**，有时可能会丢失最后一步的数据。

2.AOF持久化：以**独立日志的方式记录每次写入的命令**，重启时执行AOF中的命令即可恢复数据。优点：AOF持久化的安全性更高，保证了数据持久化的**实时性**。缺点：文件要大很多，恢复速度慢。

3.RDB-AOF持久化：这种方式是基于AOF持久化方式构建出来的。兼具RDB和AOF的优势。

## 4.说说Redis的缓存淘汰策略。

惰性删除、定期删除、maxmemory-policy；

**惰性删除**：客户端访问一个key的时候，Redis会先检查它的过期时间，如果发现过期就立刻删除这个key。

定期删除：redis会将设置了过期时间的key放到一个**独立的字典中**，并对该字典进行**每秒10次的过期扫描**，过期扫描不会遍历字典中所有的key，而是采用了一种简单的**贪心策略**，该策略如下：1、**从过期字典红随机选择20个key,2、删除这20个key中已过期的key，3、如果已过期key的比例超过25%，则重复步骤1；**

当写入数据将超出maxmemory限制时，Redis会采用maxmemory-policy所制定的策略进行数据淘汰 即 **LRU** （最近最少使用原则）LRU算法的不足之处在于,若一个key很少被访问,只是刚刚偶尔被访问了一次,则它就被认为是热点数据,短时间内不会被淘汰。

LFU算法正式用于解决上述问题,**LFU**（Least Frequently Used）是Redis4新增的淘汰策略,**它根据key的最近访问频率进行淘汰**。LFU在LRU的基础上,为每个数据增加了一个**计数器**,来统计这个数据的访问次数。当使用LFU策略淘汰数据时,首先会根据数据的访问次数进行筛选,把**访问次数最低**的数据淘汰出内存。如果两个数据的访问次数相同,LFU再比较这两个数据的访问时间,把**访问时间更早**的数据淘汰出内存

## 5.如何实现Redis高可用?

高可用即需要有**多个副本而不是单体支撑**，主节点不可用可以替换成副节点，那么多个副本需要**合理同步机制**，做到这两点即可实现高可用，redis通过**哨兵模式**，**集群模式**来扩展单节点支撑。同时做好数据同步即实现了高可用 ... 

主要有哨兵模式和集群模式这两种方式。 

哨兵模式：哨兵模式是一个分布式架构，它包含若干个哨兵节点和数据节点，每一个哨兵节点都监控着其他的数据节点和哨兵节点，**当发现节点不可达时，会对节点做下线标识**。如果被标识的是主节点，它就会与其他哨兵节点协商，可以避免误判，**当大多数哨兵节点都认为主节点不可达时**，它们便会选择出一个哨兵节点来做**自动故障转移工作，可以将从节点晋升为主节点**，同时还会实时的**通知到应用方**，整个过程自动的，实现高可用。 

集群模式：Redis集群采用**虚拟槽分区**来实现数据分片，**它把所有的键根据哈希函数映射到0-16383整数槽内**，计算公式为slot=CRC16(key)&16383，每一个节点负责维护一部分槽以及槽所映射的键值数据。

**主从模式**：一个master主机与多个slave从机，主节点负责写操作，从节点负责读操作。 
 优点：**读写分离，主节点的数据会自动复制给从节点，分担主节点的压力** 
 缺点：一旦主节点宕机，会导致部分数据未实现同步；主节点宕机与从节点都需要进行重启； 

## 6.Redis怎么实现延时消息？

redis通过**zset**有序集合来实现延时消息功能。可以将发送的时间作为**score**发送的内容作为value存储在zset中，**轮询zset检查当前时间是否达成消息的发送时间，来实现延时消息的投递。**   



## 7.Redis中的String怎么实现的?

String结构底层是**一个简单动态字符串（sds）**，支持扩容，存储字符串。所以可应用于微信文章的阅读数或点赞

Redis的String类型采用SDS(简单动态字符串)实现，结构包含**长度、空闲空间和字符数组**。支持**二进制**安全数据存储，**自动预分配空间减少内存重分配次数**，通过len字段实现O(1)时间复杂度获取长度，采用**惰性空间释放策略优化性能。**

## 8.Redis中的Zset怎么实现的?

Redis 的 ZSet 类型由 **跳表（SkipList）和哈希表（HashTable）共同实现**，跳表用于按 score 排序以**支持范围查询和有序访问**，哈希表用于快速根据成员（member）定位其分数。**插入、删除、查找操作平均复杂度为 O(log N)**，支持高效的排名、分数范围检索、排行榜等功能。ZSet 结构结合了**哈希的快速定位与跳表的有序访问特性**，是 Redis 中实现排行榜、延迟队列等典型场景的核心数据结构。

## 9.使用 Redis 实现一个排行榜怎么做？

Redis 排行榜基于 **ZSet（有序集合）** 实现，成员为用户标识，score 表示排名依据（如积分、分数等）。通过 `ZADD` 添加或更新分数，`ZREVRANGE` 获取从高到低的前 N 名，`ZREVRANK` 查询某个成员的具体排名，`ZINCRBY` 实现积分累加。ZSet 底层由跳表和哈希表组成，支持高效的排名更新和区间查询，是实现积分榜、热度榜、活跃榜等场景的常用结构。

## 10.如何用redis实现注册中心？

Redis 实现注册中心可利用 **Hash + Set + TTL 机制**。服务注册时使用 `HSET` 将服务信息（如 IP、端口、元数据）存入 `service:服务名:实例ID`，并通过 `EXPIRE` 设置 TTL，服务需定时续约。可通过 `SCAN` 或维护一个 `Set` 存储所有实例 ID。服务发现时读取 Hash 信息，过滤过期实例，实现简易的服务注册与发现机制。适合对一致性要求不高的微服务场景，如灰度发布、本地开发模拟。生产推荐使用专业注册中心如 Nacos、Eureka、Consul。

## 11.介绍一下Redis的线程模型。

Redis 使用 **单线程处理网络请求 + epoll I/O 多路复用机制**，通过一个线程完成所有命令解析、执行、响应返回，避免了多线程的上下文切换开销与锁竞争。采用 **Reactor 模式**，基于 `epoll` 监听多个客户端连接的读写事件，使用 **事件驱动机制** 实现高并发处理。内部通过队列处理定时任务（如过期键删除）、异步任务（如 AOF 重写）。虽为单线程，但在计算密集和 I/O 场景下性能非常优异。Redis 6.0 起引入 **I/O 线程**，用于读写分离进一步优化性能（开启需配置 `io-threads`）。

## 12.介绍一下Redis的事务。

Redis 事务通过 `MULTI` 开始，`EXEC` 执行，中间的命令会被顺序入队，形成一个事务队列。事务期间执行命令不会立即生效，而是等 `EXEC` 统一执行，具备**原子性（要么全部执行，要么全部不执行）**。但**不支持回滚**，中途某条命令出错不会影响其他命令执行（除非是语法错误）。可以使用 `WATCH` 监控一个或多个 key，在事务执行前若有改动，`EXEC` 会失败，实现**乐观锁机制**。`DISCARD` 可用于取消事务。

优点：简洁高效，适用于无需回滚的小型批量操作。
 缺点：不支持部分失败回滚、不具备隔离性（非串行执行，读写不隔离）。

## 13.介绍一下Redis IO多路复用模型。

Redis 的 IO 多路复用模型采用单线程结合操作系统提供的 `epoll`（Linux）或 `select/kqueue`（Unix 系统）实现高并发处理。它通过事件驱动的 **Reactor 模式**，在一个主线程中循环监听多个客户端连接的读写事件，统一由事件分发器管理，不依赖多线程/多进程，避免了上下文切换和线程锁开销。所有客户端请求被注册为事件，放入事件队列，当事件触发（如可读、可写）时，Redis 会将对应的文件描述符加入就绪队列，主线程从就绪队列中取出事件依次处理。Redis 使用这个模型能高效处理成千上万个连接，适合短连接、高频 IO 的场景，核心优势是结构简单、响应迅速，但由于是单线程处理命令，慢查询或阻塞操作仍需谨慎使用。

## 14.说说Redis的大key，为什么会产生大key？

**Redis 大 key** 是指 **单个 key 对应的 value 过大**，比如字符串内容非常长、集合元素特别多，或哈希字段数量巨大等。这类 key 会占用较多内存，并可能导致阻塞、延迟、网络压力等问题。

**大 key 的原因**

- **数据结构设计不合理**：未拆分或压入过多元素。
- **缺乏过期策略或清理机制**：数据长期堆积。
- **没有监控**：大 key 无法被及时发现处理。

**大 key 的危害**

- **阻塞 Redis 单线程，影响整体性能。**
- **网络传输耗时，客户端超时或拒绝服务。**
- **集群迁移/备份异常，影响可用性。**
- **内存占用异常，触发频繁淘汰或 OOM。**

**优化建议**

- **限制元素数量，避免一次性压入过多数据。**
- **将大结构拆成多个小 key（如分页、分桶）。**
- **设置 TTL，定期清理历史数据。**
- **使用 MEMORY USAGE、SCAN 等命令监控大 key。**

## 15.介绍一下Redis的集群模式。

Redis集群模式通过将整个数据空间划分为16384个哈希槽（hash slots），并将这些槽分配给多个节点，实现数据的自动分片和负载均衡。每个节点负责一定范围的槽，客户端根据key的哈希值路由到对应节点。集群支持主从复制，主节点负责读写，从节点做备份，主节点故障时从节点自动接管，保证高可用。节点间通过Gossip协议进行状态通信和故障检测。Redis集群优点是扩展性强、自动故障恢复和客户端智能路由，但管理复杂且跨槽操作有限制，网络分区时可能出现“分裂脑”问题。总体而言，Redis集群是Redis实现水平扩展和高可用的关键方案。

## 16.如何利用Redis实现一个分布式锁？

**方案一**：SETNX + EXPIRE

**方案二**：SETNX + value值是（系统时间 + 过期时间）

**方案三**：使用Lua脚本（包含SETNX + EXPIRE两条指令）

**方案四**：SET的扩展命令（SET EX PX NX）

**方案五**：SET EX PX NX + 校验唯一随机值，再释放锁

**方案六**：开源框架：Redisson

**方案七**：多机实现的分布式锁Redlock

